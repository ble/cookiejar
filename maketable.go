// Copyright 2012 Volker Dobler. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// +build ignore

package main

//
// recreate the tables with
//   go run maketable.go > table.go && go fmt
//

import (
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
	"sort"
	"strings"
	"time"
)

const tableUrl = "http://mxr.mozilla.org/mozilla-central/source/netwerk/dns/effective_tld_names.dat?raw=1"

type domainRule struct {
	rule string
	kind uint8
}

// list of domainRules, sortable by exceptins first, then longer first
type domainRules []domainRule

func (r domainRules) Len() int { return len(r) }
func (r domainRules) Less(i, j int) bool {
	// expetion rules (kind==1) go first
	if r[i].kind == 1 {
		return true
	}
	if r[j].kind == 1 {
		return false
	}

	// empty goes last
	if r[i].rule == "" {
		return false
	}
	if r[j].rule == "" {
		return true
	}

	// more labels go to front, wildcard (kind==2) have one extra label
	ni, nj := strings.Count(r[i].rule, "."), strings.Count(r[j].rule, ".")
	if r[i].kind == 2 {
		ni++
	}
	if r[j].kind == 2 {
		nj++
	}
	return ni > nj
}
func (r domainRules) Swap(i, j int) { r[i], r[j] = r[j], r[i] }

func main() {
	resp, err := http.Get(tableUrl)
	if err != nil {
		log.Fatal(err)
	}
	all, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		log.Fatal(err)
	}
	resp.Body.Close()

	fmt.Println("// Copyright 2012 Volker Dobler. All rights reserved.")
	fmt.Println("// Use of this source code is governed by a BSD-style")
	fmt.Println("// license that can be found in the LICENSE file.")
	fmt.Println("")
	fmt.Println("package cookiejar")
	fmt.Println("")
	fmt.Println("// This file was generated by performing")
	fmt.Println("//     go run maketable.go")
	fmt.Println("// on ", time.Now().Format(time.RFC1123Z))
	fmt.Println("// Do not modify.")
	fmt.Println("")
	fmt.Println("// A 'public suffix' is one under which Internet users can directly register")
	fmt.Println("// names.  This list is maintained on http://publicsuffix.org/")
	fmt.Println("// See there for a description of the format and further details.")
	fmt.Println("")

	tlds := make([]string, 0)              // all TLDs which are used as key in rules
	rules := make(map[string][]domainRule) // all raw rules bucket by tld

	// read in list: remove comments and empty lines, and fill tlds and rules
	lines := strings.Split(string(all), "\n")
	for _, line := range lines {
		// remove noise
		line = strings.TrimSpace(line)
		if len(line) == 0 || strings.HasPrefix(line, "//") {
			continue
		}

		// seperate tld from rule
		var tld string
		var rule string
		if i := strings.LastIndex(line, "."); i == -1 {
			if strings.Index(line, "!") != -1 {
				log.Printf("Oooops: cannot handle exception rule on tld %q", line)
				continue
			}
			tld = line
		} else {
			rule, tld = line[:i], line[i+1:]
		}
		if _, ok := rules[tld]; !ok {
			tlds = append(tlds, tld)
		}

		// construct rule, handle expetions and wildcards
		dr := domainRule{rule: rule, kind: 0}
		if len(rule)>0 && (rule[0] == '*' || rule[0] == '!') {
			k := rule[0]
			rule = rule[1:]
			if strings.Index(rule, "*") != -1 || strings.Index(rule, "!") != -1 {
				log.Printf("Oooops: cannot handle fancy rule %c%s.%s", k, rule, tld)
				continue
			}
			if k == '!' {
				dr.kind = 1
			} else {
				dr.kind = 2
				if len(rule) > 0 {
					rule = rule[1:]
				}
			}
			dr.rule = rule
		}

		rules[tld] = append(rules[tld], dr)
	}

	// sort the rules for each tld
	for _, tld := range tlds {
		sort.Sort(domainRules(rules[tld]))
	}

	fmt.Println("// domainRules maps TLDs to the list of rules belonging to this TLD.")
	fmt.Println("var domainRules = map[string][]domainRule{")

	sort.Strings(tlds)
	for _, tld := range tlds {
		fmt.Printf("\t%q: []domainRule{\n", tld)
		for _, rule := range rules[tld] {
			fmt.Printf("\t\tdomainRule{rule: %q", rule.rule)
			switch rule.kind {
			case 0: //
			case 1: fmt.Printf(", kind: exceptionRule")
			case 2: fmt.Printf(", kind: wildcardRule")
			default: panic("No such kind")
			}
			fmt.Println("},")
		}
		fmt.Println("\t},")
	}
	fmt.Println("}")
}
